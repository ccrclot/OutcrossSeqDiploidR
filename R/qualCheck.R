#' Quality Check Local Haplotypes Imputation
#'
#' `qualCheck()` calculates recombination frequencies between adjacent bins and
#' local distortions from the expected 1:1 transmission ratio.Those values
#' are then compared with user imputed thresholds for recombination and a
#' moving average for distortion to flag bins with data judged unlikely to be
#' of biological origin. The function also offers the option to save summary
#' plots as pdf.
#' @param hap_list a list of vector corresponding to physical bins with group
#' membership corresponding to local haplotypes as generated by `getHap()`.
#' @param min_rec a numeric corresponding to the minimal recombination frequency
#' with previous and next bins above which a bin is flagged.
#' @param max_rec a numeric corresponding to the maximal recombination frequency
#' with previous and next bins bellow which a bin is flagged. This value
#' should be higher than 0.5 to cover for flipped phasing.
#' @param mv_av an integer corresponding to the number of bins to use for
#' calculating the moving average of transmission ratio distortion against which
#' the local transmission ration distortion will be compared.
#' @param max_dist a numeric corresponding to the maximal absolute difference
#' between the moving average and the local transmission ratio distortion above
#' which a bin is flagged.
#' @param save_plot a logical value indicating if summary quality plots should
#' be saved.
#' @param pdf_path a character vector with the path to use to save the plots as
#' pdf.
#'
#' @return a dataframe with rows corresponding to bins (elements of
#' parameter "hap_list") and the following columns:
#' \itemize{
#'   \item"bin_i": bin of interest
#'   \item "bin_h": previous bin
#'   \item"bin_j": next bin
#'   \item"pos_bin_i": physical position of bin of interest
#'   \item"rec_hi": recombination frequency between bin h and i
#'   \item"rec_ij": recombination frequency between bin i and j
#'   \item"loc_dist": absolute value of bin i deviation from the expected 1:1
#'     transmission ratio distortion.
#'   \item"ma_dist": moving average of deviation from the expected 1:1
#'     transmission ratio distortion.
#'   \item"quality": character vector flagging aberrant bins. Either
#'     "drop (high rec)", "drop (high dist)" or "keep".}
#' @export
#'
#' @examples P1_qual_check <- qualCheck(P1_hap_list,
#'   min_rec = 0.30,
#'   max_rec = 0.70, mv_av = 11,
#'   max_dist = 0.15, save_plot = T,
#'   pdf_path = "./mypop_chr01_P1_imputation_quality_check.pdf"
#' )
#'
#' P1_flt_bins <- P1_qual_check$bin_i[which(P1_qual_check$quality == "keep")]
#' @importFrom stats filter
qualCheck <- function(hap_list, min_rec = 0.3, max_rec = 0.7,
                      mv_av = 11, max_dist = 0.10, save_plot = F,
                      pdf_path = NULL) {
  # Create df
  df <- data.frame(matrix(nrow = length(hap_list), ncol = 9))
  colnames(df) <- c(
    "bin_i", "bin_h", "bin_j", "pos_bin_i",
    "rec_hi", "rec_ij", "loc_dist", "ma_dist", "quality"
  )
  # Get pop size and last bin
  pop_size <- length(hap_list[[1]])
  last <- length(hap_list)

  # Get rec with pre and next bins and local distortion
  for (i in seq(2, length(hap_list) - 1)) {
    df[i, "bin_i"] <- names(hap_list)[i]
    df[i, "bin_h"] <- names(hap_list)[i - 1]
    df[i, "bin_j"] <- names(hap_list)[i + 1]
    df[i, "pos_bin_i"] <- (as.numeric(strsplit(
      names(hap_list)[i], "_"
    )[[1]][1]) +
      as.numeric(strsplit(
        names(hap_list)[i], "_"
      )[[1]][2])) / 2
    df[i, "rec_hi"] <- as.numeric(
      sum(abs((hap_list[[i]] - hap_list[[i - 1]]))) / pop_size
    )
    df[i, "rec_ij"] <- as.numeric(
      sum(abs((hap_list[[i]] - hap_list[[i + 1]]))) / pop_size
    )

    df[i, "loc_dist"] <- abs((table(hap_list[[i]])[1] / pop_size) - 0.5)
  }

  # Deal with first and last marker
  df[1, "bin_i"] <- names(hap_list)[1]
  df[1, "bin_j"] <- names(hap_list)[2]
  df[1, "pos_bin_i"] <- (as.numeric(strsplit(
    names(hap_list)[1], "_"
  )[[1]][1]) +
    as.numeric(strsplit(
      names(hap_list)[1], "_"
    )[[1]][2])) / 2
  df[1, "rec_hi"] <- NA#0
  df[1, "rec_ij"] <- as.numeric(
    sum(abs((hap_list[[1]] - hap_list[[2]]))) / pop_size
  )
  df[1, "loc_dist"] <- abs((table(hap_list[[1]])[1] / pop_size) - 0.5)


  df[last, "bin_i"] <- names(hap_list)[last]
  df[last, "bin_h"] <- names(hap_list)[last - 1]
  df[last, "pos_bin_i"] <- (as.numeric(strsplit(
    names(hap_list)[last], "_"
  )[[1]][1]) +
    as.numeric(strsplit(
      names(hap_list)[last], "_"
    )[[1]][2])) / 2
  df[last, "rec_hi"] <- as.numeric(
    sum(abs((hap_list[[last]] - hap_list[[last - 1]])))
    / pop_size
  )
  df[last, "rec_ij"] <- NA#0
  df[last, "loc_dist"] <- abs((table(hap_list[[last]])[1] / pop_size) - 0.5)

  # Fill moving average distortion
  df$ma_dist <- as.vector(stats::filter(df$loc_dist, rep(1 / mv_av, mv_av),
    sides = 2, circular = T
  ))

  # Fill quality
  for (i in 1:length(df[, "loc_dist"])) {
    if (((df[i, "rec_hi"] > min_rec & df[i, "rec_hi"] < max_rec) | is.na(df[i, "rec_hi"]))
        & ((df[i, "rec_ij"] > min_rec & df[i, "rec_ij"] < max_rec) | is.na(df[i, "rec_ij"])))  {
      df[i, "quality"] <- "drop (high rec)"
    } else if (abs(df[i, "loc_dist"] - df[i, "ma_dist"]) > max_dist) {
      df[i, "quality"] <- "drop (high dist)"
    } else {
      df[i, "quality"] <- "keep"
    }
  }

  # Plotting
  df$quality <- factor(df$quality, levels = c("drop (high dist)",
                                              "drop (high rec)",
                                              "keep"))
  qual_col <- c("red", "orange", "blue")
  if (save_plot == T) {
    pdf(pdf_path)
  }
  par(mfrow = c(1, 1))

  hist(df$rec_hi,
    breaks = 20,
    main = "Histogram of rec with previous bin",
    xlab = "Recombination frequency"
  )
  abline(v = min_rec, lty = 2, col = "red")
  abline(v = max_rec, lty = 2, col = "red")

  plot(df$pos_bin_i,
    df$rec_hi,
    col = qual_col[df$quality],
    main = "Distribution of rec with previous bin",
    xlab = "Physical position (Mbp)",
    ylab = "Recombination frequency"
  )
  abline(min_rec, 0, lty = 2, col = "red")
  abline(max_rec, 0, lty = 2, col = "red")
  legend("topright",
         legend = levels(df$quality),
         col = c(qual_col),
         pch = c("o", "o", "o"))

  hist(df$rec_ij,
    breaks = 20,
    main = "Histogram of rec with next bin",
    xlab = "Recombination frequency"
  )
  abline(v = min_rec, lty = 2, col = "red")
  abline(v = max_rec, lty = 2, col = "red")

  plot(df$pos_bin_i,
    df$rec_ij,
    col = qual_col[df$quality],
    main = "Distribution of rec with next bin",
    xlab = "Physical position (Mbp)",
    ylab = "Recombination frequency"
  )
  abline(min_rec, 0, lty = 2, col = "red")
  abline(max_rec, 0, lty = 2, col = "red")
  legend("topright",
         legend = levels(df$quality),
         col = c(qual_col),
         pch = c("o", "o", "o"))

  hist(df$loc_dist,
    breaks = 10,
    main = "Histogram of transmission ratio distortion",
    xlab = "Transmission ratio distortion"
  )

  plot(df$pos_bin_i,
    df$loc_dist,
    col = qual_col[df$quality],
    main = "Distribution of transmission ratio distortion",
    xlab = "Physical position (Mbp)",
    ylab = "Transmission ratio distortion"
  )
  lines(df$pos_bin_i, df$ma_dist)

  legend("topright",
    legend = c(levels(df$quality),
      paste0("mv_av ", mv_av, " bins")
    ),
    col = c(qual_col, "black"),
    pch = c("o", "o", "o", "-")
  )

  if (save_plot == T) {
    dev.off()
  }
  return(df)
}
